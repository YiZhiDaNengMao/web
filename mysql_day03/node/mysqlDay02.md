一、约束
1.概念

    1）约束是作用在表中列（字段）上的规则，用于限制加入表的数据
    2）约束的存在保证了数据库中数据的正确性、有效性和完整性
    3）作用：保证表中数据有效！！

2.约束的分类

    非空约束：not null
    唯一约束：unique
    主键约束：primary key（简称：PK）
    外键约束：foreign key（简称：FK）
    检查约束：check（mysql不支持，oracle支持）

3.非空约束：not null

    1）特点：保证列中所有数据不能有null值，也就是值不能为空
    2）语法结构：字段名 字段类型 not null

4.主键约束：primary key

    1）特点：主键是一行数据的唯一表示，要求：非空且唯一
    2）语法：字段名 字段类型 primary key
    3）分类：（代理主键 - 90%）
        代理主键：没有任何业务意义
        自然主键：表中本身存在一个非空且唯一的有效字段
            例如：身份证号码，学号，QQ号，微信号...
    4）代理主键类型
        ① varchar：用java代码随机生成一套字符串
        ② int：自动增长 / 序列（数据库自己可以完成）
            mysql：使用'auto_increment'来完成值的自动增长
            oracle：使用'sequence'来完成值的自动增长

    ★★★
    -- 有自增约束的主键字段，删除主键约束前必须先删除自增约束

5.唯一约束：unique

    1）特点：添加了唯一约束的列的值不能重复
        但是mysql中，可以有多个null值，不对null做唯一判断
    2）语法结构：字段名 字段类型 unique [key]
    
    ○主键约束 和 唯一约束 的区别
        ① 主键约束：非空且唯一
        ② 唯一约束：必须唯一，但是可以为空
        ③ 一张表中只能有一个主键约束，但是可以有多个唯一约束
    
    ★★★
    -- MySQL会给唯一约束的列上默认创建一个唯一索引
    -- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样
    -- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()
        中排在第一个的列名相同。也可以自定义唯一性约束名

    ○建表后指定唯一键约束
    #字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，
    #方式1：
        alter table 表名称 add unique key(字段列表);
    #方式2：
        alter table 表名称 modify 字段名 字段类型 unique;
    
    ○删除唯一约束
    -- ALTER TABLE USER DROP INDEX 约束名(索引名);


6.外键约束：foreign key

    1)特点:
        a.外键用来让 主表 与 从表 的数据之间建立连接,从而保证数据的一致性和完整性.
        b.多表关系中的主表和从表
            主表:主键id所在的表,约束别人的表
            从表:外键所在的表,被约束的表
    
    2)语法格式:
        [constaint 外键约束名称] foreign key(外键字段名)
        references 主表名(主键字段名)

    ★★★
    -- 创建表时添加外键约束，没有指定外键名，系统会默认指定，如：student_ibfk_1，索引名默认为列名
    -- 创建表时添加外键约束，并且指定外键名，索引名也会与之一样

---------------------------------------------------------------------

二、数据库设计
1.概念

    数据库设计就是根据业务系统的具体需求，结合所选用的数据库，
    建立好表结构以及表与表之间的管理关系。

2.数据库设计的步骤

    1）需求分析（数据是什么？数据具体有哪些属性？数据与属性的特点是什么？）
    2）概要设计（E-R图:实体关系图 => 对数据进行逻辑建模）
    3）逻辑结构设计（将E-R图转换成多张表，确认各表中的主、外键关系）

3.表与表之间的关系

    1）一对一
        常见栗子：
            人 => 身份证，用户 => 用户详情
        使用场景：多用于表拆分，将一个实体中经常使用的字段放在一张表中，不经常使用
                的字段放在领一张表中，提高查询效率
        
    2）一对多（多对一）
        常见栗子：部门和员工，班级和学生，用户和订单
        实现方式：在（从表）多的一方建立外键，指向（主表）一的一方的主键

    3）多对多
        常见栗子：学生和课程，商品和订单
        实现方式：建立第三张表，中间表至少包含两个外键，分别关联两方的主键

4.数据库三范式
    
    1）概念：三范式就是设计数据库的规则
    ——————————————————————————————————————————————————————
    2）第一范式：
        ① 最核心、最重要的的范式，所有标的设计都需满足这一范式
        ② 要求任何一张表都必须有主键，每一个字段符合原子性
        学生编号    学生姓名    联系方式
        ----------------------------
        1001        张三      xx@x,x-xx
        1002        李四      xx@x,x-xx
        1001        王五      xx@x,x-xx
        不符合第一范式の原因：
            a 练习方式可以拆分成邮箱和电话，不符合原子性
            b 没有主键约束
    ——————————————————————————————————————————————————————
    3）第二范式：
        ① 建立在第一范式的基础之上
        ② 要求所有非主键字段完全依赖主键,不要产生部分依赖
    ——————————————————————————————————————————————————————
    4）第三范式：
        ① 建立在第二范式的基础之上
        ② 要求所有非主键字段直接依赖主键,不要产生传递依赖
5.表的设计总结
    一对一：一对一，外键唯一
    一对多：两张表，多的表加外键
    多对多：三张表，关系表两个外键


三、多表查询（连接查询/表连接查询）
1.笛卡尔积现象

    当两张表进行连接查询，没有任何限制，最终查询结果条数，是两张表条数的成绩，
    把这种现象称之为笛卡尔积现象

    ○ 表的别名
       a 使用别名可以简化查询
       b 列名前使用表名前缀可以提高查询效率
    
2.多表查询的分类

    1）交叉连接（cross join)
        语法格式1：select 字段 表1 cross join 表2 where 字句
        语法格式2：select 字段 表1,表2 where 字句
        
    2）内连接
        ① 分类
            a 等值连接
                栗子：e.deptno = d.deptno

            b 非等值连接
                栗子：between s.losal and s.hisal
            
            c 全连接
                将一张表看作两张表使用

    3）外连接
        分类：
            ① 左外连接（左连接）
            语法格式：
                SELECT 字段列表
                FROM A表 LEFT [OUTER] JOIN B表
                ON 关联条件
                WHERE 等其他子句;

            ② 右外连接（右连接）
            语法格式：
                SELECT 字段列表
                FROM A表 RIGHT [OUTER] JOIN B表
                ON 关联条件
                WHERE 等其他子句;

            理解:将join右边的表看成主表使用
                主要是为了将这张表的数据全部查询出来
                捎带

四、子查询
1.概念
   
     一条select语句的结果作为，另一条select语句的一部分

2.特点：

    a 子查询必须放在小括号中
    b 子查询一般作为父查询的结果条件使用

3.子查询常见分类（出现位置）

    select
        (select子查询)
    from
        (select子查询)
    where
        (select 子查询)

五、事务
1.概念

    1）数据库事务是一种机制，一个操作序列，包含了一组数据库操作命令
    
    2）事务把所有的命令作为一个整体，一起向系统提交或撤回请求

    3）总结：事务是一个不可分割的工作逻辑单元

2.事务相关SQL

    1）只有DML语句（insert | update | delete）

    2）原因：只有以上三个语句可以对数据库表中数据进行改变
        ☆ 只要涉及到增删改查就一定要考虑到安全问题！！！

    3）结论：事务的存在就是为了保证数据的完整性和安全性

3.事务原理

    1）提交事务（默认）：让所有增删改 操作的数据提交到本地文件上，实现数据的修改然后让所有历史记录进行清空
    
    2）回滚事务：清空所有的历史记录，但不会将数据提交到本地文件中

4.事务特性（ACID）

    1）原子性：事务是最小的工作单位，不可再分
    2）一致性：必须保证DML语句同时成功或失败
    3）隔离性：事务A与事务B之间具有隔离，必须是独立的
    4）持久性：最终数据必须持久化到硬盘文件中，事务才算成功的结束

5.隔离等级

    1）第一级别：读未提交
        理解：可以读到没有提交的数据
        存在问题：脏读，表示读到了脏（没有提交）的数据

    2）第二级别：读已提交（oracle默认事务级别）
        理解：读到已经提交的数据
        解决问题：脏读
        存在问题：☆不可重复读☆ 事务A提交数据前后，事务B分别读同一数据，得到不同的值，
                即无法重复读到一个值，通常出现在update语句中

    3）第三级别：可重复读（mysql默认事务级别）
        理解：在事务进行过程中，不允许其它事务进行修改和删除操作（即解决了不可重复读）
        解决问题：不可重复读
        存在问题：☆幻读☆前后两次读到的数据多了或是少了，像幻觉。
                     通常出现在insert、delete语句中

    4）第四级别：序列化读 / 串行化读
        理解：序列化读是最高的事务隔离等级，主要通过强制事务排序来解决幻读问题
        解决问题：所有问题
        存在问题：这种隔离等级的效率相对低下,并且开销大.所以一般情况下不推荐使用
        实现过程：在每个数据行上加上共享锁实现，从而避免了脏读、不可重复度、可重复度的问题
六、视图

七、存储引擎

八、索引

九、锁机制